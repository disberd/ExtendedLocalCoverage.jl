# The CSS and html structure within this file was mostly generated by Claude and further refined.

"""
    modern_css_styles() -> String

Return modern CSS styling for the coverage report.
Fully static, no runtime JavaScript required.
"""
function modern_css_styles()
    return read(joinpath(@__DIR__, "style.css"), String)
end

function highlight_to_html(highlighted::Union{SubString{<:AnnotatedString}, AnnotatedString})
    result = IOBuffer()
    try
        for (content, annots) in Base.eachregion(highlighted)
            print(result, "<span")
            if !isempty(annots)
                print(result, " class=\"")
                print(result, join(map(a -> a.value, annots), " "))
                print(result, "\"")
            end
            print(result, ">")
            print(result, content)
            print(result, "</span>")
        end
    catch e
        # If highlighting fails, return escaped plain text
        return String(highlighted)
    end
    
    return String(take!(result))
end

function calculate_file_stats(file::FileCoverageSummary)
    total_lines = file.lines_tracked
    covered_lines = file.lines_hit
    missed_lines = total_lines - covered_lines
    coverage_pct = total_lines == 0 ? 100.0 : (covered_lines / total_lines) * 100.0
    
    return (;
        total = total_lines,
        covered = covered_lines,
        missed = missed_lines,
        coverage = coverage_pct,
        missing_str = format_gaps(file)
    )
end

"""
    coverage_badge_class(coverage::Float64) -> String

Return CSS class for coverage badge based on coverage percentage.
"""
function coverage_badge_class(coverage::Float64)
    if coverage >= 80.0
        return "coverage-excellent"
    elseif coverage >= 60.0
        return "coverage-good"
    else
        return "coverage-poor"
    end
end

# Make all paths relative to pkgdir and always using `/` as separator (even on Windows)
normrelpath(file::String, pkg_dir::String) = replace(relpath(file, pkg_dir), "\\" => "/")

@component function file_summary_table_component(; data::PackageCoverage)
    @div {class = "summary-table-section"} begin
        @h2 "üìã Files Overview"
        @table {class = "file-summary-table"} begin
            @thead begin
                @tr begin
                    @th "File"
                    @th {class = "stats-cell"} "Total Lines"
                    @th {class = "stats-cell"} "Covered"
                    @th {class = "stats-cell"} "Missed"
                    @th {class = "stats-cell"} "Coverage"
                    @th "Missing Lines"
                end
            end
            @tbody begin
                for (idx, file) in enumerate(data.files)
                    fname = normrelpath(file.filename, data.package_dir)
                    stats = calculate_file_stats(file)
                    badge_class = coverage_badge_class(stats.coverage)
                    file_anchor = "file-$idx"
                    
                    @tr begin
                        @td begin
                            @a {class = "file-link", href = "#$file_anchor"} $(fname)
                        end
                        @td {class = "stats-cell"} $(stats.total)
                        @td {class = "stats-cell"} $(stats.covered)
                        @td {class = "stats-cell"} $(stats.missed)
                        @td {class = "stats-cell"} begin
                            @span {class = "coverage-badge $badge_class"} "$(round(stats.coverage, digits=2))%"
                        end
                        @td {class = "missing-cell"} $(isempty(stats.missing_str) ? "‚Äî" : stats.missing_str)
                    end
                end
            end
        end
    end
end
@deftag macro file_summary_table_component end

# Component that renders the summary metrics section
@component function summary_section_component(; data::PackageCoverage)
    lines_covered = data.lines_hit
    lines_valid = data.lines_tracked
    coverage_pct = (lines_covered / lines_valid) * 100
    
    @div {class = "summary"} begin
        @div {class = "metric"} begin
            @div {class = "metric-label"} "Total Coverage"
            @div {class = "metric-value"} "$(round(coverage_pct, digits=2))%"
            @div {class = "metric-subtext"} "$(lines_covered) of $(lines_valid) lines"
        end
        @div {class = "metric"} begin
            @div {class = "metric-label"} "Lines Covered"
            @div {class = "metric-value"} "$(lines_covered)"
            @div {class = "metric-subtext"} "executable lines"
        end
        @div {class = "metric"} begin
            @div {class = "metric-label"} "Lines Uncovered"
            @div {class = "metric-value"} "$(lines_valid - lines_covered)"
            @div {class = "metric-subtext"} "need testing"
        end
        @div {class = "metric"} begin
            @div {class = "metric-label"} "Files"
            @div {class = "metric-value"} "$(length(data.files))"
            @div {class = "metric-subtext"} "in project"
        end
    end
end
@deftag macro summary_section_component end

# Component that renders a single line of source code with coverage highlighting
@component function code_line_component(; line_num::Int, content::AbstractString, hits::Union{Int,Nothing})
    line_class = if isnothing(hits)
        "code-line line-neutral"
    elseif hits > 0
        "code-line line-covered"
    else
        "code-line line-uncovered"
    end
    
    # Apply syntax highlighting
    highlighted_content = let
        # io = IOBuffer()
        # show(io, MIME"text/html"(), content)
        # String(take!(io)) |> HypertextTemplates.SafeString
        highlight_to_html(content) |> HypertextTemplates.SafeString
    end
    
    @div {class = line_class} begin
        @div {class = "line-number"} $line_num
        @div {class = "line-content"} @text highlighted_content
    end
end
@deftag macro code_line_component end

# Component that renders a single file card with coverage information and source code
@component function file_card_component(; file::FileCoverageSummary, pkg_dir::String, file_index::Int, lines_hits::Vector{Union{Int,Nothing}})
    stats = calculate_file_stats(file)
    source_lines = highlighted_lines(file.filename, pkg_dir)
    
    badge_class = coverage_badge_class(stats.coverage)
    file_anchor = "file-$file_index"
    
    @div {class = "file-card", id = file_anchor} begin
        @div {class = "file-header"} begin
            @div {class = "file-name"} $(normrelpath(file.filename, pkg_dir))
            @div {class = "file-stats"} begin
                @span {class = "stat"} begin
                    @span {class = "coverage-badge $badge_class"} "$(round(stats.coverage, digits=2))%"
                end
                @span {class = "stat"} begin
                    @span "üìä $(stats.covered)/$(stats.total) lines"
                end
                @span {class = "stat"} begin
                    @span "‚ùå $(stats.missed) missed"
                end
            end
        end
        
        # Source code section
        if !isempty(source_lines)
            @div {class = "source-code"} begin
                for (i, line) in enumerate(source_lines)
                    @code_line_component {
                        line_num = i,
                        content = line,
                        hits = i > length(lines_hits) ? nothing : lines_hits[i]
                    }
                end
            end
        else
            @div {class = "source-code"} begin
                @div {style = "padding: 20px; text-align: center; color: #666;"} begin
                    "Source code not available"
                end
            end
        end
        
        # Missing lines section
        if !isempty(stats.missing_str)
            @div {class = "missing-lines"} begin
                @strong "Uncovered Lines: "
                @text stats.missing_str
            end
        end
    end
end
@deftag macro file_card_component end

"""
    generate_native_html_report(cobertura_file::String, output_file::String;
                                 title::String="Coverage Report",
                                 pkg_dir::String=dirname(cobertura_file))

Generate a modern, static HTML coverage report from a Cobertura XML file using HypertextTemplates.jl.

# Arguments
- `cobertura_file`: Path to the Cobertura XML file
- `output_file`: Path where the HTML report should be written
- `title`: Title for the HTML report (default: "Coverage Report")
- `pkg_dir`: Root directory of the package for resolving source file paths (default: directory of cobertura_file)

# Example
```julia
generate_native_html_report(
    "coverage/cobertura-coverage.xml",
    "coverage/report.html",
    title="MyPackage Coverage"
)
```
"""
function generate_native_html_report(infofile::String, output_file::String;
                                     title::String="Coverage Report",
                                     pkg_dir::String)
    # Parse the Cobertura XML file
    raw_coverage = LCOV.readfile(infofile)
    data = eval_coverage_metrics(raw_coverage, pkg_dir)
    
    # Build and render the HTML document
    function render_html(io)
        # We disable debug mode which is automatically enabled in HypertextTemplates.jl when Revise is loaded. This is a hack as mentioned in https://github.com/MichaelHatherly/HypertextTemplates.jl/issues/36#issuecomment-3004032438
        ctx = IOContext(io, HypertextTemplates._include_data_htloc() => false)
        @render ctx begin
            @html {lang = "en"} begin
                @head begin
                    @meta {charset = "UTF-8"}
                    @meta {name = "viewport", content = "width=device-width, initial-scale=1.0"}
                    @title $title
                    @style @text modern_css_styles()
                end
                @body begin
                    @div {class = "container"} begin
                        # Header
                        @header begin
                            @h1 $title
                        end
                        
                        # Summary metrics
                        @summary_section_component {data = data}
                        
                        # File summary table
                        @file_summary_table_component {data = data}
                        
                        # File coverage details
                        @div {class = "files-section"} begin
                            @h2 "üìÅ File Coverage Details"
                            for (idx, file) in enumerate(data.files)
                                @file_card_component {file = file, pkg_dir = pkg_dir, file_index = idx, lines_hits = raw_coverage[idx].coverage}
                            end
                        end
                        
                        # Footer
                        @footer begin
                            "Generated by ExtendedLocalCoverage.jl using HypertextTemplates.jl"
                        end
                    end
                end
            end
        end
    end
    
    # Write to file
    open(output_file, "w") do io
        render_html(io)
    end
    
    @info "HTML coverage report generated: $output_file"
    return output_file
end

function highlighted_lines(io::IO)
    highlighted = highlight(io)
    map(eachsplit(highlighted, '\n')) do line
        endswith(line, '\r') ? line[1:end-1] : line # Deal with Windows line endings
    end
end
function highlighted_lines(filepath::String, pkg_dir::String)
    fullpath = joinpath(pkg_dir, filepath)
    isfile(fullpath) || throw(ArgumentError("Source file not found: $fullpath"))
    return open(fullpath, "r") do io
        highlighted_lines(io)
    end
end