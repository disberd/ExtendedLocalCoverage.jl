# The CSS and html structure within this file was mostly generated by Claude and further refined.

"""
    modern_css_styles() -> String

Return modern CSS styling for the coverage report.
Fully static, no runtime JavaScript required.
"""
function modern_css_styles()
    return read(joinpath(@__DIR__, "style.css"), String)
end

function highlight_with_show end
function highlight_with_classes end

function calculate_file_stats(file::FileCoverageSummary)
    total_lines = file.lines_tracked
    covered_lines = file.lines_hit
    missed_lines = total_lines - covered_lines
    coverage_pct = total_lines == 0 ? 100.0 : (covered_lines / total_lines) * 100.0

    return (;
        total = total_lines,
        covered = covered_lines,
        missed = missed_lines,
        coverage = coverage_pct,
        missing_str = format_gaps(file),
    )
end

"""
    coverage_badge_class(coverage::Float64) -> String

Return CSS class for coverage badge based on coverage percentage.
"""
function coverage_badge_class(coverage::Float64)
    return coverage >= 80 ? "coverage-excellent" :
           coverage >= 60 ? "coverage-good" :
                            "coverage-poor"
end

@component function file_summary_table_component(; data::PackageCoverage)
    @div {class = "summary-table-section"} begin
        @h2 "üìã Files Overview"
        @table {class = "file-summary-table"} begin
            @thead begin
                @tr begin
                    @th "File"
                    @th {class = "stats-cell"} "Total Lines"
                    @th {class = "stats-cell"} "Covered"
                    @th {class = "stats-cell"} "Missed"
                    @th {class = "stats-cell"} "Coverage"
                    @th "Missing Lines"
                end
            end
            @tbody begin
                for (idx, file) in enumerate(data.files)
                    fname = file.filename
                    stats = calculate_file_stats(file)
                    badge_class = coverage_badge_class(stats.coverage)
                    file_anchor = "file-$idx"

                    @tr begin
                        @td begin
                            @a {class = "file-link", href = "#$file_anchor"} $(fname)
                        end
                        @td {class = "stats-cell"} $(stats.total)
                        @td {class = "stats-cell"} $(stats.covered)
                        @td {class = "stats-cell"} $(stats.missed)
                        @td {class = "stats-cell"} begin
                            @span {class = "coverage-badge $badge_class"} "$(round(stats.coverage, digits=2))%"
                        end
                        @td {class = "missing-cell"} $(
                            isempty(stats.missing_str) ? "‚Äî" : stats.missing_str
                        )
                    end
                end
            end
        end
    end
end
@deftag macro file_summary_table_component end

# Component that renders the summary metrics section
@component function summary_section_component(; data::PackageCoverage)
    lines_covered = data.lines_hit
    lines_valid = data.lines_tracked
    coverage_pct = (lines_covered / lines_valid) * 100

    @div {class = "summary"} begin
        @div {class = "metric"} begin
            @div {class = "metric-label"} "Total Coverage"
            @div {class = "metric-value"} "$(round(coverage_pct, digits=2))%"
            @div {class = "metric-subtext"} "$(lines_covered) of $(lines_valid) lines"
        end
        @div {class = "metric"} begin
            @div {class = "metric-label"} "Lines Covered"
            @div {class = "metric-value"} "$(lines_covered)"
            @div {class = "metric-subtext"} ""
        end
        @div {class = "metric"} begin
            @div {class = "metric-label"} "Lines Uncovered"
            @div {class = "metric-value"} "$(lines_valid - lines_covered)"
            @div {class = "metric-subtext"} ""
        end
        @div {class = "metric"} begin
            @div {class = "metric-label"} "Tracked Files"
            @div {class = "metric-value"} "$(length(data.files))"
            @div {class = "metric-subtext"} ""
        end
    end
end
@deftag macro summary_section_component end

# Component that renders a single line of source code with coverage highlighting
@component function code_line_component(;
    line_num::Int,
    content::AbstractString,
    hits::Union{Int,Nothing},
    html_function
)
    line_class = if isnothing(hits)
        "code-line line-neutral"
    elseif hits > 0
        "code-line line-covered"
    else
        "code-line line-uncovered"
    end

    # Apply syntax highlighting
    highlighted_content = html_function(content) |> HypertextTemplates.SafeString

    @div {class = line_class} begin
        @div {class = "line-number"} $line_num
        @div {class = "line-content"} @text highlighted_content
    end
end
@deftag macro code_line_component end

# Component that renders a single file card with coverage information and source code
@component function file_card_component(;
    file::FileCoverageSummary,
    pkg_dir::String,
    file_index::Int,
    lines_hits::Vector{Union{Int,Nothing}},
    lines_function,
    html_function,
)
    stats = calculate_file_stats(file)
    source_lines = extract_file_lines(lines_function, file.filename, pkg_dir)

    badge_class = coverage_badge_class(stats.coverage)
    file_anchor = "file-$file_index"

    @div {class = "file-card", id = file_anchor} begin
        @div {class = "file-header"} begin
            @div {class = "file-name"} $(file.filename)
            @div {class = "file-stats"} begin
                @span {class = "stat"} begin
                    @span {class = "coverage-badge $badge_class"} "$(round(stats.coverage, digits=2))%"
                end
                @span {class = "stat"} begin
                    @span "üìä $(stats.covered)/$(stats.total) lines"
                end
                @span {class = "stat"} begin
                    @span "‚ùå $(stats.missed) missed"
                end
            end
        end

        # Source code section
        if !isempty(source_lines)
            @div {class = "source-code"} begin
                for (i, line) in enumerate(source_lines)
                    @code_line_component {
                        line_num = i,
                        content = line,
                        hits = i > length(lines_hits) ? nothing : lines_hits[i],
                        html_function
                    }
                end
            end
        else
            @div {class = "source-code"} begin
                @div {style = "padding: 20px; text-align: center; color: #666;"} begin
                    "Source code not available"
                end
            end
        end

        # Missing lines section
        if !isempty(stats.missing_str)
            @div {class = "missing-lines"} begin
                @strong "Uncovered Lines: "
                @text stats.missing_str
            end
        end
    end
end
@deftag macro file_card_component end

"""
    generate_html_report(lcov_file, html_file; title = nothing, pkg_dir = nothing)

Generate a static HTML report from a LCOV file using a native Julia solution.

The `lcov_file` and `html_file` arguments are the full paths to the LCOV file used as input and of the HTML file to be generated, respectively.

# Keyword arguments

- `title = "Package Coverage Report"` is the title used at the top of the HTML report.
- `pkg_dir` is the directory of the package being covered. It is used to generate the source code links in the HTML report.
"""
function generate_html_report(
    lcov_file::String,
    output_file::String;
    title::String = "Coverage Report",
    pkg_dir::String,
    lines_function = highlighted_lines,
    html_function = highlight_with_show,
)
    # Parse the Cobertura XML file
    raw_coverage = LCOV.readfile(lcov_file)
    # Make the package directory absolute
    pkg_dir = abspath(pkg_dir)
    # We make the filepaths absolute
    foreach(raw_coverage) do fc
        fc.filename = abspath(pkg_dir, fc.filename)
    end
    data = eval_coverage_metrics(raw_coverage, pkg_dir)

    # Build and render the HTML document
    function render_html(io)
        # We disable debug mode which is automatically enabled in HypertextTemplates.jl when Revise is loaded. This is a hack as mentioned in https://github.com/MichaelHatherly/HypertextTemplates.jl/issues/36#issuecomment-3004032438
        ctx = IOContext(io, HypertextTemplates._include_data_htloc() => false)
        @render ctx begin
            @html {lang = "en"} begin
                @head begin
                    @meta {charset = "UTF-8"}
                    @meta {
                        name = "viewport",
                        content = "width=device-width, initial-scale=1.0",
                    }
                    @title $title
                    @style @text modern_css_styles()
                end
                @body begin
                    @div {class = "container"} begin
                        # Header
                        @header begin
                            @h1 $title
                        end

                        # Summary metrics
                        @summary_section_component {data = data}

                        # File summary table
                        @file_summary_table_component {data = data}

                        # File coverage details
                        @div {class = "files-section"} begin
                            @h2 "üìÅ File Coverage Details"
                            for (idx, file) in enumerate(data.files)
                                @file_card_component {
                                    file = file,
                                    pkg_dir = pkg_dir,
                                    file_index = idx,
                                    lines_hits = raw_coverage[idx].coverage,
                                    lines_function,
                                    html_function
                                }
                            end
                        end

                        # Footer
                        @footer begin
                            "Generated by ExtendedLocalCoverage.jl using HypertextTemplates.jl"
                        end
                    end
                end
            end
        end
    end

    # Write to file
    open(output_file, "w") do io
        render_html(io)
    end

    @info "HTML coverage report generated: $output_file"
    return output_file
end

function highlighted_lines end

function plain_lines(io::IO)
    collect(eachline(io))
end
function extract_file_lines(lines_function, filepath::String, pkg_dir::String)
    fullpath = joinpath(pkg_dir, filepath)
    isfile(fullpath) || throw(ArgumentError("Source file not found: $fullpath"))
    return open(fullpath, "r") do io
        lines_function(io)
    end
end